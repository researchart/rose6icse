ID,Repo ID,Practices,Notes,Guidelines 1,Guidelines 2,Guidelines 3,Guidelines 4
1,AcutronicRobotics/moveit2,"In MoveIt, the simplest user interface is through the MoveGroupInterface class. It provides easy to use functionality for most operations that a user may want to carry out, specifically setting joint or pose goals, creating motion plans, moving the robot, adding objects into the environment and attaching/detaching objects from the robot. ",MoveGroup single interface for the user/developer.,G1,,,
2,AcutronicRobotics/moveit2,This node serves as an integrator: pulling all the individual components together to provide a set of ROS actions and services for users to use.,,G1,,,
3,AcutronicRobotics/moveit2,move_group can be configured using the ROS param server from where it will also get the URDF and SRDF for the robot.,Put the URDF and SRDF for the robot in the ROS parameters server.,G2,,,
4,AcutronicRobotics/moveit2,"move_group will look on the ROS param server for other configuration specific to MoveIt including joint limits, kinematics, motion planning, perception and other information",Put other system-level configuration files in the ROS parameters server.,G3,,,
5,AcutronicRobotics/moveit2,"move_group is structured to be easily extensible - individual capabilities like pick and place, kinematics, motion planning are actually implemented as separate plugins with a common base class. The plugins are configurable using ROS through a set of ROS yaml parameters and through the use of the ROS pluginlib library. Most users will not have to configure move_group plugins since they come automatically configured in the launch files generated by the MoveIt Setup Assistant.",Extensibility,G4,,,
6,AcutronicRobotics/moveit2,"MoveIt works with motion planners through a plugin interface. This allows MoveIt to communicate with and use different motion planners from multiple libraries, making MoveIt easily extensible. The interface to the motion planners is through a ROS Action or service (offered by the move_group node). ",Extensibility,G4,,,
7,AcutronicRobotics/moveit2,"Planning request adapters allow for pre-processing motion plan requests and post-processing motion plan responses. Pre-processing is useful in several situations, e.g. when a start state for the robot is slightly outside the specified joint limits for the robot. Post-processing is needed for several other operations, e.g. to convert paths generated for a robot into time-parameterized trajectories. MoveIt provides a set of default motion planning adapters that each perform a very specific function.",,G5,,,
8,AcutronicRobotics/moveit2,"The fix start state bounds adapter fixes the start state to be within the joint limits specified in the URDF. The need for this adapter arises in situations where the joint limits for the physical robot are not properly configured. The robot may then end up in a configuration where one or more of its joints is slightly outside its joint limits. In this case, the motion planner is unable to plan since it will think that the starting state is outside joint limits. The “FixStartStateBounds” planning request adapter will “fix” the start state by moving it to the joint limit. However, this is obviously not the right solution every time - e.g. where the joint is really outside its joint limits by a large amount. A parameter for the adapter specifies how much the joint can be outside its limits for it to be “fixable”.",,G5,,,
9,AcutronicRobotics/moveit2,"The planners in OMPL are abstract; i.e. OMPL has no concept of a robot. Instead, MoveIt configures OMPL and provides the back-end for OMPL to work with problems in Robotics.",Grace Note: Architectural????,G2,,,
10,AcutronicRobotics/moveit2,3D perception in MoveIt is handled by the occupancy map monitor. The occupancy map monitor uses a plugin architecture to handle different kinds of sensor input as shown in the Figure above. ,,G2,G4,,
11,AcutronicRobotics/moveit2,"MoveIt uses a plugin infrastructure, especially targeted towards allowing users to write their own inverse kinematics algorithms. Forward kinematics and finding jacobians is integrated within the RobotState class itself. The default inverse kinematics plugin for MoveIt is configured using the KDL numerical jacobian-based solver. This plugin is automatically configured by the MoveIt Setup Assistant.",,G4,,,
12,AcutronicRobotics/moveit2,"Collision checking is a very expensive operation often accounting for close to 90% of the computational expense during motion planning. The Allowed Collision Matrix or ACM encodes a binary value corresponding to the need to check for collision between pairs of bodies (which could be on the robot or in the world). If the value corresponding to two bodies is set to 1 in the ACM, this specifies that a collision check between the two bodies is not needed. This would happen if, e.g., the two bodies are always so far way that they would never collide with each other.",,G6,,,
13,AcutronicRobotics/moveit2,"This split has advantages for multi-threaded collision detection. In motion planning, it is often necessary to check a large amount of robot poses against the same current world environment. Consequently, the split allows to have one CollisionRobot per thread and only a single CollisionWorld. Keeping a single CollisionWorld gives memory advantages especially in the case of complicated point cloud world environments.",,G7,,,
14,AcutronicRobotics/moveit2,"The robot link geometries are saved as member variables. When self-collision checks are executed a new FCL manager is created and all links are added to it. As the link geometries are only calculated once and stored persistently (including their local AABB), adding them to the new collision manager is cheap.",Decisions about what to store persistently,G37,,,
15,AlexisTM/flyingros,rosrun flyingros_web web_export - Send every usefull informations on the web though ROSBridge (to avoid to subscribe to 10 topics from the web app),Use one single node as interface to external systems.,G1,,,
16,ANYbotics/elevation_mapping,"Node: elevation_mapping
This is the main Robot-Centric Elevation Mapping node. It uses the distance sensor measurements and the pose and covariance of the robot to generate an elevation map with variance estimates.",Single node application - Grace note: architectural? best practice?,G1,,,
17,at-wat/neonavigation,"In the neonavigation meta-package, the motion control that controls the vehicle to follow the generated path based on [5] and collision prevention are separated from the planner; then the motion control and collision prevention can have the faster control frequency. For example, global/local planner frequency is around 5 Hz, and the motion control and collision prevention can be 50 Hz ... The main advantage of this meta-package is that the collision avoidance frequency can be faster than the conventional, planned path, always taking the global goal into account.",Different rates for different purposes,G9,,,
18,at-wat/neonavigation,"In some cases, with a complex narrow place in that difficult-to-find path, the planner gets slower compared to the conventional navigation meta-package since it considers the relatively larger number of possible motions. In this case, a watchdog timer in the planner publishes zero velocity commands until the path is planned. After finding the path in such a case, the planner gets faster since the path near the previous one is preferentially searched due to the hysteresis factor of the cost function.",Watchdog with 0-based placeholders,G6,,,
19,auengagroactu_sens/dji_matrice100_onboard_sdk_ros,"Note: there are two timestamps in msgs. The first one is the timestamp in ROS header, which is the timestamp from ROS. The other one called ts comes from the drone, it is a timestamp from Matrice 100, unit in 1/400s.",Double timestamp,G10,,,
20,AutonomyLab/ardrone_autonomy,"The drone will takeoff, land or emergency stop/reset if a ROS std_msgs/Empty message is published to ardrone/takeoff, ardrone/land and ardrone/reset topics respectively.",Publish an empty message as a way to trigger atomic actions.,G11,,,
21,AutonomyLab/ardrone_autonomy,"Driver Update Frequencies: The driver can operate in two modes: real-time or fixed rate. When the realtime_navdata parameter is set to True, the driver publishes any received information instantly. When it is set to False, the driver caches the received data first, then sends them at a fixed rate. This rate is configured via looprate parameter. The default configuration is: realtime_navdata=False and looprate=50.

Please note that if looprate is smaller than the drone’s transmission frequency, some data is going to be lost. The driver’s start-up output shows the current configuration.",,G12,,,
22,AutonomyLab/ardrone_autonomy,The legacy Navdata publishing can be disabled by setting the enable_legacy_navdata parameter to False (legacy navdata is enabled by default).,Support for legacy modes.,G17,,,
23,AutonomyLab/ardrone_autonomy,"You can access almost all sensor readings, debug values and status reports sent from the AR-Drone by using Selective Navdata. If you set any of following parameters to True, their corresponding Navdata information will be published to a separate topic. For example if you enable enable_navdata_time, the driver will publish AR-Drone time information to ardrone/navdata_time topic. Most of the names are self-explanatory. Please consult AR-Drone SDK 2.0’s documentation (or source code) for more information. All parameters are set to False by default.",Selective telemetry data,G13,,,
24,AutonomyLab/bebop_autonomy,"Unlike Parrot ARDrone, Bebop does not constantly transmit all on-board data back to the host device with high frequency. Each state variable is sent only when its value is changed. In addition, the publication rate is currently limited to 5 Hz. The driver publishes these states selectively and when explicitly enabled through a ROS parameter.",Limit publication rate and data transmissions,G12,,,
25,AutoRally/autorally,"WiFi is used to remotely monitor high bandwidth, non-time critical data from the platform such as images and diagnostic information. A 900 MHz XBee Pro provides a low-latency, low-bandwidth wireless communication channel.",,G14,,,
26,AutoRally/autorally,"The XBee radio onboard the robot also receives a global software runstop signal at 5 Hz, and the position and velocity of other AutoRally robots within communication range at up to 10 Hz. The runstop message allows all robots within radio range, each running its own self-contained software system, to be stopped simultaneously with one button. Any program in the AutoRally system can publish a runstop ROS message",Runstop button,G15,,,
27,AutoRally/autorally,"GPSD is a daemon used to bridge GPS time sources with traditional time servers. GPSD runs on the compute box and receives the GPS PPS signal and NMEA messages. Processed timing information is communicated through a low latency shared memory channel to Chrony, the time server running on the computer. Compared to traditional Network Time Protocol (NTP) servers, Chrony is designed to perform well in a wide range of conditions including intermittent network connections, heavily congested networks, changing temperatures, and systems that do not run continuously. Chrony’s control of system time makes time synchronization transparent to programs running on the computer. The IMU provides a dedicated pin for a PPS input. In addition to the PPS signal, it requires the current GPS second (GPS time is given in seconds since Jan 6, 1980) to resolve the time of the PPS pulse. This value can be derived from the computer’s system clock. The IMU uses these two pieces of information to synchronize its own clock and time stamp each measurement with an accuracy of significantly less than one millisecond to system time.",Time synchronization via GPS and a clock server,G10,,,
28,AutoRally/autorally,"The deadman relay monitors the quality of the incoming PWM control signal so that the throttle signal is automatically disabled in the event of a signal failure between the transmitter and receiver. Additionally, the throttle signal is connected through the normally open contact of the deadman relay so that the throttle signal disengages in the case of a power failure on the robot.",Safety,G5,,,
29,AutoRally/autorally,"On startup, the chassis interface loads a priority list of controllers from a configuration file. The priority list is used while operating to determine which actuator commands arriving from various controllers are sent to the actuators. The priorities encode a hierarchy of controllers and define a mechanism to dynamically switch between controllers and use multiple controllers simultaneously. This system allows high priority controllers to subsume control from lower priority controllers, as desired. Additionally, each actuator can be controlled by a separate controller such as a waypoint following controller for the steering and a separate velocity controller for the throttle and front brake.",,G8,,,
30,AutoRally/autorally,The simulation and physical platform implement identical ROS messaging interfaces to enable seamless software migration between hardware and simulation,Simulator and HW should have the same interface,G16,,,
31,autowarefoundation/autoware,"GPS/GNSS receivers typically generate NMEA-compliant sentences (text strings), which is entirely supported by Autoware, via the serial interface. Therefore, we believe that as long as the device is NMEA compliant, virtually all GPS/GNSS products, would be compatible for Autoware with the existing nmea2tfpose node.",Stick to standards for benefiting in terms of change impact,G17,,,
32,b-it-bots/mas_domestic_robotics,"The functionalities in this repository are organised based on the main capabilities a domestic robot needs to possess. Each of these has its own ROS metapackage, which further includes a set of packages related to that particular functionality.",Architect the system around the main capabilities of the robot,G18,,,
33,bluesat/owr_software,A node which pings the ground station to check whether the network connection has dropped out and publishes the result,Network ping,G19,,,
34,bluesat/owr_software,"This node takes in the input from the two xbox controllers and turns it into a nice standardised format defined in RoverDefs.h, this means we can add new controllers by implementing a different version of this node (and not editing the board control stuff). If possible control system changes should be done in this node. ",Change prediction,G2,,,
35,byu-magicc/rosplane,All nodes can be throttled to operate at lower rates as processing limitations require.,,G20,,,
36,byu-magicc/rosplane,Each ROS node has a key task to perform.,Modularity,G18,,,
37,cra-ros-pkg/robot_localization,"Per-sensor input customization. If a given sensor message contains data that you don’t want to include in your state estimate, the state estimation nodes in robot_localization allow you to exclude that data on a per-sensor basis.",Consider only subset of sensors output,G13,,,
38,cra-ros-pkg/robot_localization,"Fusion of an arbitrary number of sensors. The nodes do not restrict the number of input sources. If, for example, your robot has multiple IMUs or multiple sources of odometry information, the state estimation nodes within robot_localization can support all of them.",Fuse multiple sensors,G23,,,
39,cra-ros-pkg/robot_localization,"Continuous estimation. Each state estimation node in robot_localization begins estimating the vehicle’s state as soon as it receives a single measurement. If there is a holiday in the sensor data (i.e., a long period in which no data is received), the filter will continue to estimate the robot’s state via an internal motion model.",Estimate state asap. Resilience?,G22,,,
40,dji-sdk/Onboard-SDK-ROS,"GPS signal health is between 0 and 5, 5 is the best condition. Use gps_position for control only if gps_health >= 3. Published at 50 Hz.",Include signal health for signals that are critical and used in other calculations,G23,,,
41,dji-sdk/Onboard-SDK-ROS,The service to activate the drone with app ID and key pair.,Service for starting up the robot,G24,,,
42,dji-sdk/Onboard-SDK-ROS,Query drone firmware version.,Provide dedicated nodes for knowing the lower levels of the system,G25,,,
43,edinferno/edinferno,"In the earlier version of our framework, the behaviour module was tightly coupled with other perception-related modules (vision, localisation), with information flowing directly between these components. We have revised this structure, so that our previously developed strategies are now written in the XABSL scripting language. XABSL is fully decoupled from the core functionalities of the system, and as such there is no need to recompile the entire code every time a change is made. So, this facilitates the development and comparison of new behaviours that were previously harder to test. ",They also mention energy in their paper (see here: https://pdfs.semanticscholar.org/1b16/23782df74baa184701df547d9647db57e473.pdf),G18,,,
44,fkie/iop_core,"For the IOP-OCU it looks like IOP components, but in the background they use the ROS data. In the second case the ROS/IOP-Bridge components are used on the OCU side to process the JAUS data and make it available for ROS-GUI, like rqt:","Two modalities: one for interfacing with external systems (ROS is masked) and one purely ROS-based for interfacing with ROS tools like Rviz, Qt, etc.",G26,,,
45,florisvb/multi_tracker,"Listens to the camera topic specified in delta_video_parameters.yaml, and saves the pixels and values for any pixels that change more than the specified threshold. This results in a dramatically compressed filesize relative to a full resolution video. Artifacts are kept at an absolute minimum. ","Specific to video, but has to do with optimizing storage and potentially bandwidth.",G27,,,
46,frankaemika/franka_ros,This package contains the hardware abstraction of the robot for the ROS control framework based on the libfranka API.,Isolate HW-specific components,G2,,,
47,frankaemika/franka_ros,"To recover from errors and reflexes the franka_control::ErrorRecoveryAction can be called. That can be done from an action client or by simply publishing on the action goal topic:

rostopic pub -1 /franka_control/error_recovery/goal franka_control/ErrorRecoveryActionGoal ""{}""
After recovery, the franka_control_node restarts the controllers that were running. That is possible as the node does not die when robot reflexes are triggered or errors are occurred.",,G5,,,
48,frankaemika/franka_ros,"Also, for the sake of safety, if a reflex or error occurs on any of the robots, the control loop of all robots will stop until they are recovered.",,G15,,,
49,googlecartographer/cartographer_ros,"Only the first echo is used. If num_multi_echo_laser_scans is greater than 1, multiple numbered echoes topics (i.e. echoes_1, echoes_2, echoes_3, … up to and including num_multi_echo_laser_scans) will be used as inputs for SLAM.",Multiple data? Multiple topics!,G23,,,
50,googlecartographer/cartographer_ros,All services responses include also a StatusResponse that comprises a code and a message field. ,,G23,,,
51,googlecartographer/cartographer_ros,"Generating the map is expensive and slow, so map updates are in the order of seconds. You can can selectively include/exclude submaps from frozen (static) or active trajectories with a command line option.",,G6,,,
52,hasauino/rrt_exploration,"Running additional instances of the global frontier detector can enhance the speed of frontier points detection, if needed.",,G22,,,
53,hasauino/rrt_exploration,"In multi-robot configuration, each robot runs an instance of the local_rrt_frontier_detector. So for a team of 3 robots, there will be 4 nodes for detecting frontier points; 3 local detectors and 1 global detector. Running additional instances of the local frontier detector can enhance the speed of frontier points detection, if needed.

All detectors will be publishing detected frontier points on the same topic (/detected_points).",,G22,,,
54,hasauino/rrt_exploration,"The filter nodes receives the detected frontier points from all the detectors, filters the points, and passes them to the assigner node to command the robots. Filtration includes the delection of old and invalid points, and it also dicards redundant points.",,G5,,,
55,hrnr/m-explore,"Incremental updates on costmap. Not necessary if source of map is always publishing full updates, i.e. does not provide this topic.","Publish only updates if possible instead of full data structures (e.g., maps)",G13,,,
56,hrnr/m-explore,Estimating transforms between grids is cpu-intensive so you might want to tune estimation_rate parameter to run re-estimation less often if it causes any troubles.,Have parameters to adjust how often expensive operations run.,G20,,,
57,hrnr/m-explore,"Main disadvantage of this setup is a single-point-of-failure roscore service. Although the communication in the ROS network is always peer-to-peer, roscore is required for advertisement, enumerating topics and establishing communication. This might not be acceptable for exploration robots communicating over unreliable link. multirobot map merge can work transparently with both configurations as it is not tied to any particular communication between robots, allowing a great flexibility.",,G38,,,
58,hrnr/robo-rescue,This project uses layered architecture to create multiple layers of abstraction. Bottom layer is Hardware Abstraction Layer. With aim to hide maximum of hardware differences. Middle layer (DPL) aggregates multiple data streams from HAL into single data stream. Top layer holds higher algorithms which operate on the whole robot. Thanks to clearly defined layers is this architecture suitable for fast prototyping of robots.,I have seen this layered architecture in multiple projects (including the paper that I sent today),G2,,,
59,hrnr/robo-rescue,"HAL receives raw data from sensors and sends raw low level commands to joints. Data may come from real robots as well as simulation. Nodes of HAL should transform data ,which come from variety of bus interfaces and sensor or actuator types. This layer is therefore uniquely build for each robot depending on its configuration. This layer also holds function of synchronizer. In case of simulation it should set ROS default time to simulated. Otherwise it should time-stamp data with ROS default system time.",,G16,,,
60,hrnr/robo-rescue,"DPL aggregates multiple data streams received from HAL. These messages must be fused together to provide overall robot state information. All data should be transformed to robot main frame_ID called base_link and then processed. Output from this stack of ROS packages should be come standardized ROS messages like Odom, PointCloud ,LaserScan. These messages are commonly used in algorithms. This layer also includes passing messages from algorithms to bottom layers. These are mostly represented by Twist commands for movement of the robot. Twist message is translated into angular velocities of robot motors.
",,G17,,,
61,hrnr/robo-rescue,"This project use standard ROS TF tree. It is formation of coordinate frames of all vital parts of the robot. Robot model is described in URDF file. TF uses forward and inverse transformation in between the frames. The main structure of the robot consists of frames: map -> odom -> base_footprint -> base_link ->[robot structure ,sensors and actuators].
","Note sure if this is relevant, but this fragment talks about standardization.",G17,,,
62,introlab/rtabmap_ros,"map_optimizer
This node is for advanced usage only as it is preferred to use graph optimization already inside rtabmap node (which is the default). This node can be used to optimize the graph outside rtabmap node. The benefice to do that is that we can keep optimized the global map instead of the local map of rtabmap. You can then connect output mapData_optimized to map_assembler to get the optimized grid, proj and cloud maps assembled again. Note that processing time for map optimization using this node is not bounded (which is the case in rtabmap node).",,G6,G7,,
63,introlab/rtabmap_ros,"Synchronize RGB, depth and camera_info messages into a single message. You can then use subscribe_rgbd to make rtabmap or odometry nodes subscribing to this message instead. This is useful when, for example, rtabmap is subscribed also to a laser scan or odometry topic published at different rate than the image topics. We can then make sure that images are correctly synchronized together. If you have camera publishing on the network, this can be also a good format to synchronize images before sending them on the network, to avoid synchronization issues when the network is lagging.","There is a single fragment for stereo sync (Synchronize left image, right image and camera_info messages into a single message)",G22,G28,,
64,introlab/rtabmap_ros,Synchronize odometry with RGB-D images. Useful to correctly show clouds in RVIZ when odometry refresh rate is low comparatively to clouds to show.,,G22,,,
65,introlab/rtabmap_ros,Throttle at a specified rate the stereo data.,,G20,,,
66,ipa320/cob_command_tools,"Part of the freely available ROS components that run on the service robot is the driver framework ros_canopen. The stack is running under Linux, with or without linkage to ROS. It has been implemented in C++ and is divided into several layers (Figure 3) in order to enhance its flexibility and extensibility. The connection to the CAN network is enabled by SocketCAN, which is included in the mainline kernel and supports an increasing number of interface devices. Regarding the CANopen master implementation, the driver is auto- matically configured based on the EDS files for the slave devices. It supports most services like Network Management (NMT), Service Data Objects (SDO), Process Data Objects (PDO), Synchronization Objects (SYNC), Emergency Objects (EMCY), or Heartbeats. On top of it, a ROS interface was implemented that provides further configuration and intro- spection functionalities.",,G2,G4,G8,G25
67,ipa320/cob_command_tools,"it is fully integrated with another software framework, ros_control, which abstracts the controller interface from the actual hardware implementation.",,G2,,,
68,ipa320/srs_public,"Robotic Hardware Independence: SRS is not bond to one single platform; the software must be as robot hardware independent as possible. To archive this target, some software modules in the architecture need function as device drivers and thus are tied to hardware. The rest of modules should operate only on higher level hardware-independent abstractions. ",This is another reference to having a layered architecture.,G2,,,
69,ipa320/srs_public,"Parallel Processing: Applications involved in SRS requires considerable amount of computational resources for planning and control to sustain the local intelligence of the robot. At the same time, the SRS software has to satisfy long term learning and analysis requirement. Furthermore, it should also satisfy real-time constraints required by the real world applications. Generally, the onboard computational resources of the robot cannot support all the required computation, so separation the computational load across multiple sources e.g. off board machines is required.",,G9,,,
70,ipa320/srs_public,"Modularity and Collaborative Development: SRS project involves dozens of researchers and developers from different organisation, discipline and background. Since it targets to build large systems contributing to a sizable code base, it is of high importance to enforce modularity and interoperability between the software components and organise them in a systematic way allowing concurrent work on the system from all the partners in a fashion that components can be developed and verified separately and integrated efficiently in the future.",,G18,,,
71,ipa320/srs_public,"Cross Platform Communication: SRS communication requires transfer of data and commands between various hardware platforms, operating systems and applications. In order to achieve a versatile concept of robot communications it is very useful to build the SRS communications based on an efficient and reliable foundation. Furthermore, although most of robotic resources are available within Linux environment, some sensors and development kit come with only binary Windows drivers. Therefore, SRS software system must be able to deal with multiple operating system, and cross platform communication is required.",,G2,G3,G38,
72,ipa320/srs_public,"Integration with other Code Base: SRS intended to take the advantage of the latest progress of robotic development. It should be capable of re-use code available from other source. For example identified suitable candidates are the navigation system, and simulators from the Player project, vision algorithms from OpenCV, and planning algorithms from OpenRAVE, among many others. In each case, it should only to expose various configuration options and to route data into and out of the respective software, with as little wrapping or patching as possible",,G3,G4,,
73,ipab-slmc/exotica,Problem and task definitions are generic across solvers and can be loaded easily from configuration files as dynamic plug-ins without the need to recompile.,Take advantage of configuration files for things that may change between executions.,G3,G4,,
74,ipab-slmc/exotica,"To further support the extensibility of EXOTica, the motion solvers and the task maps are loaded into EXOTica as plug-ins.",Extensibility via plug-ins,G4,,,
75,irvs/ros_tms,"The ROS-TMS consists of 73 packages categorized into 11 groups and 151 processing nodes. Re-configuration of structures, for instance adding or removing modules such as sensors, actuators, and robots, is simple and straightforward owing to the high flexibility of the ROS architecture.",Take advantage of ROS modularity,G18,,,
76,jhu-dvrk/dvrk-ros,"In general, telerobotic software can be arranged into the following functional layers (see Fig. 5): hardware interface (I/O), low-level control (e.g., PID), high-level control, teleoperation, and application",Layered architecture,G39,,,
77,jhu-dvrk/dvrk-ros,"This layer also defines data structures for configuration parameters, such as sensor scale factors and the mapping of hardware to robot joints. Configuration file parsers can be created to populate these data structures from any defined format.",Configuration files for parameters,G2,G3,,
78,jhu-dvrk/dvrk-ros,"One challenge for such a component-based approach is data synchronization; this is especially true for servo loop control running at a high frequency of 1 kHz or greater. If a separate thread is created for each servo control loop and the I/O component, it is likely that the feedback data used in the servo loop control could be out of synchronization and potentially affect controller performance. As illustrated in Fig. 5, our solution puts the I/O component and all servo control (PID) components in one single thread, while keeping the advantage of a component-based approach.",Data synchronization,G9,,,
79,lagadic/vision_visp,Another consequence is that it is not necessary to modify the controller library when adding a new feature,,G4,,,
80,lagadic/vision_visp,"One of the challenges dealing with a visual servoing package is that it must deal with multiple robotic platforms as well as with various framegrabbers. Obviously, the package does not (and cannot) provide an interface with all possible robots and grabbers, but we built it in order to facilitate adding new hardware",,G2,G4,,
81,leggedrobotics/free_gait,"The implementation of Free Gait with the robot specific software is realized through adapters. An adapter is responsible to provide the actual state of the robot and forward the desired robot state to the robot controller. Through the adapter, the execution of the Free Gait commands is controlled with a free to choose sampling time ∆t.",,G5,G2,,
82,leggedrobotics/free_gait,"By separating the motion generation with the motion execution, Free Gait is robot platform agnostic, enabling to easily port motion generation methods and algorithms to a different robot. As Free Gait is also independent of the underlying whole body controller, implementing different control methods for the same control tasks requires only to write a new adapter without additional overhead. Furthermore, it is often useful to simulate or preview the motion plan, which can be accomplished by writing adapters for each and viewing the Free Gait commands before the execution on the real robot.",,G2,G18,,
83,mcgill-robotics/ros-interop,The interop client can also run in an offline mode which reads mission and obstacle information from a file instead of the server. This means that an internet connection is not required when operating in this mode.,,G29,,,
84,NiryoRobotics/niryo_one_ros,"This picture gives you an idea about the different layers of the application. Let’s start with the bottom (hardware). The hardware layer is, well, anything that directly deals with hardware ... Then we have the control layer ... On top of that, the motion planning layer is responsible for finding inverse kinematics and building a path for the robot ... The next layer is the commander layer ... On the top of this layer, we finally have the external/user layer.",Another instance of a layered architecture,G39,,,
85,NiryoRobotics/niryo_one_ros,"On the top of this layer [the ROS command level], we finally have the external/user layer. We have developed a set of high level interfaces between the ROS commander layer and the outside. The main 2 goals of those interfaces are : 1. hiding the ROS complexity for users who want to use high level commands, and 2. Providing a way to control the robot from a non-ROS environment (more on that later).",,G26,,,
86,OSLL/slam-constructor,The package provides the utility lslam2d_bag_runner to launch algorithms in the offline mode to process datasets in BAG format.,,G29,,,
87,osrf/capabilities,"Only run those capabilities that are required by currently running applications (e.g., to save power and/or processing)",Energy as a concern.,G6,,,
88,osrf/capabilities,The capability server provides a ROS API that is implemented using ROS messages and services with a ROS topic for event feedback.,Services for calling capabilities and topic for feedback.,NO_GUIDANCE,,,
89,osrf/capabilities,"There is also a Python “client” API that provides an easy-to-use Python interface for interacting with the capability server. Under the hood this client API uses the ROS API so that the client API can be used on a remote computer, which is different from the computer that the capability server is running on.",,G26,,,
90,osrf/capabilities,"The capabilities system goes one step further by not only defining the type of data being sent, but also over which named topics the data will be sent, effectively defining how the system components will be connected. ROS concepts other than topics are also covered by capability interfaces, including: services, actions, parameters, and dynamic parameters. By defining the required types and names for each of the ROS concepts, robot developers can set up their robot to send and receive data according to the interface, and app developers can depend on that interface’s being available when designing their applications.

This approach is analogous to how the Android mobile operating system allows Android apps to require and access ""capabilities"" provided by the mobile device.",,G18,,,
91,PX4/avoidance,"The local_planner requires less computational power but it doesn't compute optimal paths towards the goal since it doesn't store information about the already explored environment. An in-depth discussion on how it works can be found in this thesis. On the other hand, the global_planner is computationally more expensive since it builds a map of the environment. For the map to be good enough for navigation, accurate global position and heading are required. An in-depth discussion on how it works can be found in this thesis. The safe_landing_planner classifies the terrain underneath the vehicle based on the mean and standard deviation of the z coordinate of pointcloud points. The pointcloud from a downwards facing sensor is binned into a 2D grid based on the xy point coordinates. For each bin, the mean and standard deviation of z coordinate of the points are calculated and they are used to locate flat areas where it is safe to land.",,G9,,,
92,RoboJackets/igvc-software,Our path planning is split into global planning and local planning in order to efficiently generate paths that are locally feasible for Jessii but also globally accurate in a computationally efficient manner.,,G9,,,
93,RoboJackets/igvc-software,"given that we have a source of absolute position from the GPS and a relatively accurate accelerometer from the IMU, the Extended Kalman Filter (EKF) running in our localization module is able to compensate for a faulty IMU with accurate positions and accelerations.",Combine global and local planning/localization,G23,G21,,
94,robotics-in-concert/rocon_multimaster,"One of the main goals of the capabilities is to make writing robot agnostic ""apps"" easier. If a robot can declare that it implements the standardized interface for the navigation capability, then an app can rely on the ROS interface used to utilize that capability. Making it easier for app developers to work independently of the robot developers and making it easier to integrate onto new robots. This is analogous to the use of Messages in topics and services, and that has proven to be very effective at easing integration of disparate parts of the system. This package provides the capability_server ROS node which loads all capability spec files from packages on the ROS_PACKAGE_PATH and provides a ROS interface for querying and running those capabilities.",,G4,G18,G8,
95,robotics-in-concert/rocon_multimaster,"The gateway will be the public frontend for a ros master and is intended to act much like a gateway on a local area network controlling what is exposed and what is forwarded between the local ros master and the outside world (other ros systems). The intention is to generalise this kind of interface beyond tools that previously existed (foreign_relay, master_sync and fki_multimaster) and also make their configuration/usage as simple as possible. Goals
Gate_G01 : do not burden non-multimaster systems with unnecessary overhead
Gate_G02 : do not interface directly with foreign ros masters (put the gateway inbetween)
Gate_G03 : support all ros api types (topics, services and actions).
Gate_G04 : auto-discover other gateways (pre-configured, zeroconf or name server)
Gate_G05 : provide quality of network connection statistics between systems
Gate_G06 : control what ros api should be put on a public interface (simplicity and security)
Gate_G07 : support flipping of local ros api to a remote gateway (control what and where your share)
Gate_G08 : support pulling of publicly exposed remote ros api from a remote gateway (open sharing)
Gate_G09 : configure/manage the type of connections created between systems (unreliable, comporessed, ...)
Gate_G9 : peer to peer gateway interactions (true multimaster, not two multimaster)
Gate_G10 : access control to permit/block requests for flipping/pulling
Gate_G11 : decouple from higher level components such as the app_manager (re-usable building block).
Decisions
Gate_D01a : sit alongside, do not extend rosmaster itself
Gate_D01b : modular components called when necessary (discovery, sync, zeroconf, multicast)
Gate_D02 : adapter like interface that accepts/makes requests on one side and interacts with the ros master api on the other
Gate_D03 : leave concepts like bundling of ros api in capabilities (or similar) to higher level components
Gate_D04 : gateway discovery mechanisms should be optional and varied
By hand (yaml), centralised server (redis), zeroconf or multicast.
Gate_D05 : assume each gateway represents a single system interface that needs to be monitored, this makes it simpler and is typical for robots, even if there is multiple machines connected internally
Gate_D06a : default settings for a gateway should not expose anything.
Gate_D06b : convenience option to dump all local topics on the public interface.
Gate_D07a : gateways should have the option to block flip requests.
Gate_D07b : flip requests should have enough details for passing on to the ros master api.
Gate_D07c : convenience option to flip all local interfaces to a remote.
Gate_D07d : convenience option to flip all public interfaces to a remote.
Gate_D09a : specify transport type and hints at the system level (e.g. reliable/unreliable configuration via roslaunch).
Gate_D09b : more complete transport types (multi-language unreliable, compression etc).
Gate_D12 : do not make decisions about what to expose, where and how - gateways should be just a mechanism that can be controlled by policies dictated by higher level components.",,G1,G38,G5,G19
96,robotics-in-concert/rocon_multimaster,"Backed by a redis key-value store, a rocon hub provides a centralised place to store relevant information for multiple ros systems interacting over a LAN. It's most common use is to act as a kind of name server assisting ros subsystems to find each other",,G7,,,
97,ros-controls/ros_control,"The backbone of the framework is the Hardware Abstraction Layer, which serves as a bridge to different simulated and real robots. This abstraction is provided by the hardware_interface::RobotHW class; specific robot implementations have to inherit from this class. Instances of this class model hardware resources provided by the robot such as electric and hydraulic actuators and low-level sensors such as encoders and force/torque sensors. It also allows for integrating heterogeneous hardware or swapping out components transparently whether it is a real or simulated robot. [....] Through these typed interfaces this abstraction enables easy introspection, increased maintainability and controllers to be hardware-agnostic.",,G2,G16,,
98,ros-controls/ros_control,"The lifecycle of controllers is not static. It can be queried and modified at runtime through standard ROS services provided by the controller_manager. Such services allow to start, stop and configure controllers at runtime.","If we start finding a standard for nodes lifecycle, then we gain in terms of configurability, adaptability",G30,,,
99,ros-perception/opencv_apps,"With opencv_apps, you can run a lot of functionalities OpenCV provides in the simplest manner in ROS, i.e., running a launch file that corresponds to the functionality.","Generic package, the specific nodes to be run are declared in the launch file",G3,,,
100,ros-planning/navigation,"One costmap is used for global planning, meaning creating long-term plans over the entire environment, and the other is used for local planning and obstacle avoidance.",,G7,,,
101,ros-planning/navigation2,The reason for the change was to make it so that global and local planners would be Action Servers and could be replaced at launch or run time with other implementations providing the same Action.,,G4,G17,,
102,ros-planning/navigation2,All these changes make it possible to replace any of these nodes at launch/run time with any other algorithm that implements that same interface.,,G4,G17,,
103,ros-planning/navigation2,"In contrast to the ROS1 navigation map server, the nav2 map server will support a variety of map types, and thus some aspects of the original code have been refactored to support this new extensible framework. In particular, there is now a MapLoader abstract base class and type-specific map loaders which derive from this class. There is currently one such derived class, the OccGridLoader, which converts an input image to an OccupancyGrid and makes this available via topic and service interfaces. The MapServer class is a ROS2 node that uses the appropriate loader, based on an input parameter.",,G4,G3,,
104,ros-planning/navigation2,"Critics like to give things scores. Once we know we're not at the goal and have a bunch of candidate trajectories, we evaluate them based on a collections of TrajectoryCritics. Here's the life-cycle.",,G30,,,
105,ROS-PSE/arni,"Advanced ROS Network Introspection (ARNI) extends the /statistics features introduced with Indigo and completes the collected data with measurements about the hosts and nodes participating in the network. These are gathered from an extra node that has to run on each host machine. All statistics or metadata can be compared against a set of reference values using the monitoring_node. The rated statistics allow to run optional countermeasures when a deviation from the reference is detected, in order to remedy the fault or at least bring the system in a safe state.",,G25,G19,,
106,ros/actionlib,"The action client and server communicate with each other using a predefined action protocol. This action protocol relies on ROS topics in a specified ROS namespace in order to transport messages. In some cases, however, if the service takes a long time to execute, the user might want the ability to cancel the request during execution or get periodic feedback about how the request is progressing. The actionlib package provides tools to create servers that execute long-running goals that can be preempted. It also provides a client interface in order to send requests to the server.",Specify the protocol of the messages you expect,G31,,,
107,ros/geometry2,"A distributed system
Value: No bottleneck process and all processes are one step away for minimal latency.

Implementation: Everything is broadcast and reassembled at end consumer points. There can be multiple data sources for tf information. Data is not required to be synchronized by using interpolation. Data can arrive out of order.",,G5,G32,G23,
108,ros/geometry2,"Only transform data between coordinate frames at the time of use
Value: Efficiency, both computational, bandwidth, and simplicity.",,G33,,,
109,ros/geometry2,"Support queries on data which are timestamped at times other than the current time
Value: Handle data processing lag gracefully.

Implementation: Interface class stores all transform data in memory and traverses tree on request.",,G6,G20,,
110,ros/geometry2,"Only have to know the name of the coordinate frame to work with data
Value: Ease of use for users/developers.

Implementation: Use string frame_ids as unique identifiers.",,G34,,,
111,ros/geometry2,"The system doesn't need to know about the configuration before hand and can handle reconfiguring on the fly
Value: Generic system for any configuration.

Implementation: Use directed tree structure. It allows fast traversal(order n where n is the depth of the tree) when evaluating a transform. It can be reconfigured simply by redefining a link. It does not require any structure verification or maintenance of the data structure, except for maintaining a sorted linked list of data for each link.",,G9,,,
112,ros/geometry2,"Core is ROS agnostic
Value: Code reuse.

Implementation: Core library is C++ class. A second class provides ROS interface and instantiates the core library.",,G35,,,
113,ros/geometry2,"Thread Safe Interface
Values: Can be used in a multithreaded program.

Implementation: Mutexes around data storage for each frame. Mutexes around frame_id lookup map. Each are individually locked and unlocked, neither can block the other.",,G36,,,
114,ros/geometry2,"Multi-Robot Support
Values: Can be used with multiple robots with the same or similar configuration.

Implementation: Use a tf_prefix similar to a namespace for each robot.",,G34,,,
115,ros/geometry2,"Native Datatype Interfaces
Value: Users can interact with tf2_ros in their native datatypes, the conversion is handled implicitly by the library.

Implementation: There is a tf2::convert(A, B) templated method that converts from type A to type B using the geometry_msg types as the common factor.

And as long as any datatype provides the methods msgType toMsg(datatype) and fromMsg(msgType, datatype) it can be automatically converted to any other datatype with the same methods defined and a matching msgType.

All tf2_ros interfaces can then be called with native type in and native type out. Note, the native type in and out do not need to match.",,G17,,,
116,ros/geometry2,"tf messages do not deal with low bandwidth networks well
Within a single well connected network tf works fine, but as you transition to wireless and lossy networks with low bandwidth the tf messages start to take up a large fraction of the available bandwidth. This is partially due to the many to many nature and partially due to the fact that there is no way to choose the desired data rate for each consumer.
Solution: Add support for /tf_static topic which will only publish latched topics.",,G19,,,
117,ros/geometry2,"tf doesn't keep a long history
The default timescale for storage is 10 seconds which is fine for live operations, but storing anything longer than that requires storing the data in a known fixed frame such that it will be transformable later.
Solution: A long history can be kept in a specialized node and queried remotely.",,G37,,,
118,rosflight/rosflight,Sensor stream topics are only advertised if they are being transmitted by the autopilot.,,NO_GUIDANCE,,,
119,RoverRobotics/rr_openrover_basic,This means that if the robot gets unplugged and replugged in this value may change. It is recommended to setup a udev rule for the robot that will always name it something like /dev/rover and to set this parameter to the same thing so that if it gets unplugged and replugged in things will work still.,Use logical names,G34,,,
120,RoverRobotics/rr_openrover_basic,If enabled this driver will stop the robot if nothing new is published to cmd_vel/managed in the timeout window. Its highly recommended that this be set to true.,,G30,,,
121,spencer-project/spencer_people_tracking,Well-structured ROS message types and clearly defined interfaces make it easy to integrate custom detection and tracking components.,,G30,G31,G17,
122,spencer-project/spencer_people_tracking,"We highly encourage reuse of these messages to benefit from our rich infrastructure of detection, tracking, filtering and visualization components! Existing detection and tracking algorithms can often easily be integrated by publishing additional messages in our format, or by writing a simple C++ or Python node that converts between message formats.",,G17,G5,,
123,Tabjones/pacman_vision,"Finally the Gui provides two button Master Disable and Master Reset:
- Master disable lets you pause all the functionality of the node, including modules, stopping cloud stream processing and consequently lowering cpu usage to near zero. The node however will remain registered on ROS network, so that, when you re-enable it again all the functionalities will resume as if nothing happened.
- Master reset lets you reset the node completely, killing all the modules and reloading the last loaded configuration.",,G15,,,
124,team-vigir/flexbe_behavior_engine,Provides a communication channel between the onboard behavior executive and any custom user interface for providing data during runtime.,,G1,,,
125,team-vigir/flexbe_behavior_engine,It is recommended to bundle all custom nodes and configuration files for behavior execution in launch files if things get more complex.,,G39,,,
126,team-vigir/flexbe_behavior_engine,Each behavior is generated as an own ROS package.,,G18,,,
127,team-vigir/flexbe_behavior_engine,"In the Configuration view of the user interface, you can set a namespace for your behaviors if required.",,G34,,,
128,team-vigir/vigir_footstep_planning_core,"The footstep planning system is designed to be easily adaptable to the target robot system. For this purpose the entire footstep planning pipeline has been ""pluginized"", thus the system can be easily modified by adding or replacing plugins in the pipeline. This allows for adaptive code execution even during runtime which is superior to classic parameter-based systems. Although plugins can provide new code for the pipeline, already existing code is kept untouched which simplifies code maintenance and improves code stability. In order to achieve this kind of versatile code management, the vigir_pluginlib has been developed.",Plugins,G4,,,
129,team-vigir/vigir_footstep_planning_core,"The vigir_pluginlib uses the C++ RTTI mechanism to determine the functionality of each instantiated plugin based on implemented parent classes. This information helps the plugin manager to resolve any kind of plugin request done by the application during runtime and allows to manage a heterogeneous plugin database. For clarification, heterogeneous denotes indeed that you can load plugins of different type in one single manager and therefore have convenient centralized access to all your plugins no matter which interface they actually implement. If you need a plugin implementing a specific interface, then the plugin manager tries best effort to deliver them. Polymorphic plugins are indeed allowed, thus a single plugin may implement the interfaces of multiple interface plugins and still will be retrieved correctly.

Furthermore the plugin manager comes with full service and action interfaces, thus the plugin composition used by your application can be remotely reconfigured during runtime using the provided rqt widget or external nodes.",Plugins,G4,,,
130,team-vigir/vigir_footstep_planning_core,A Plugin Aggregator is a collector for a set of plugins implementing a specified interface and simplifies handling of such sets. It obtains automatically all plugins from the plugin manager and provides the option to update parameters of those plugins,Plugins,G4,,,
131,team-vigir/vigir_footstep_planning_core,The vigir generic params solves the conflicting issue of having a fixed ROS message structure at build time and the varying content of parameter sets due to individual compositions of plugins during run time. It is designed as substitution for the classical ROS Parameter Server while using the same YAML syntax for configuration files and providing the same interfaces for accessing parameters. This design consideration makes it very convenient to use for ROSfamiliar developers. The vigir generic params implements additional features such as a flexible structure for parameter sets that can be shared via ROS messages and a parameter set management to allow quick software reconfiguration by just providing multiple configuration files. In addition a generic graphical user interface allows modifying those parameter sets online.,more details here: https://www.sim.informatik.tu-darmstadt.de/publ/download/2016_Stumpf_footstep_planning_framework_Humanoids.pdf,G3,G4,,
132,team-vigir/vigir_footstep_planning_core,"The parameter and plugin system delivers the adaptability needed to cope with different humanoid systems and therefore form the basic infrastructure of the proposed footstep planning framework. In order to apply the plugin system, the footstep planner pipeline has been investigated for injection points where a user might want to affect the behavior of the planner. For each such injection point, a plugin type has been defined",more details here: https://www.sim.informatik.tu-darmstadt.de/publ/download/2016_Stumpf_footstep_planning_framework_Humanoids.pdf,G4,,,
133,team-vigir/vigir_footstep_planning_core,"Furthermore plugins do not live in isolation, which should be taken into account because they can also access and use each other as well. The most common case is the StepPlanMsgPlugin that allows custom plugins to access robot specific variables encoded into the step plan.",more details here: https://www.sim.informatik.tu-darmstadt.de/publ/download/2016_Stumpf_footstep_planning_framework_Humanoids.pdf,G4,,,
134,team-vigir/vigir_footstep_planning_core,"One of our main goals is keeping the overhead of the plugin system low in order to maintain high planning efficiency. It is clearly inefficient to request needed plugins from the manager for each single iteration during planning. For this reason, the planner retrieves all plugins once at the beginning of each planning request and initializes them with the given parameters for this request.",more details here: https://www.sim.informatik.tu-darmstadt.de/publ/download/2016_Stumpf_footstep_planning_framework_Humanoids.pdf,G4,G8,,
135,tue-robotics/ed,"ED is one re-usable environment description that can be used for a multitude of needed functionalities. Instead of having different environment representations for localization, navigation, manipulation, interaction, etc, you now only need one. An improvement in this single, central world model will reflect in the performances of the separate robot capabilities.",,G7,,,
136,tue-robotics/ed,"ED has a plugin system. In itself, ED is 'just' a data structure containing a world representation. Functionality is added through plugins, which run concurrently and query and update the world model in a thread-safe manner. This makes the system easily extendable.",,G4,,,
137,tue-robotics/ed,"ED's default localization module consists of a fast particle filter implementation and sensor models which always take into account the most recent state of the world. This means that if the world representation improves while the robot is running, localization becomes better. The localization module is more efficient and accurate than the well-known AMCL-module and no separate occupancy grid is needed.",,G9,,,
138,tue-robotics/ed,"ED can be visualized using a web-based GUI. This enables users to monitor the state of the world using a large variety of systems, including PC's, smart phones and tablets.",,G1,,,
139,udg_cirs/cola2_core,There is a package in charge of the vehicle's safety: cola2_safety. It contains several safety controllers and also checks some important values inside the architecture. If some of these values are not inside a user predefined threshold the vehicle can abort a mission and/or surface the vehicle automatically. All the parameters used by these nodes are defined in the file:,Safety,G3,G5,,
140,udg_cirs/cola2_core,"""Some important safety parameters like battery level, navigation sensors status, communications etc. are checked using the following schema:

- A diagnostic message is generated containing some relevant information (e.g. battery level, time since last sensor update, water inside...).
- All these diagnostic messages are combined using the diagnostic aggregator node.
- The diagnostics aggregated message can be visualized by the rqt_robot_monitor or by the COLA2 web interface (see basic usage).
- Additionally to visualize this aggregated diagnostics message, it is possible to enable the diagnostics_supervisor node that receives this message and applies a set of rules that depend on some values predefined by the user in the cola2_(s2/g500)/config/safety.yaml file.
- If any of the rules checked by the diagnostics_supervisor is true, then it calls a recovery action.
- Recovery actions are defined as ROS services and are implemented in the recovery_actions node (see below).""

The diagnostic messages that contain these relevant information can be published by the drivers itself (e.g. the battery driver publishes the battery level), by a third node that uses this information (e.g. the navigator node publishes the last time that a navigation sensor has generated a data package), or by a specific node (e.g. the virtual_cage node generates a diagnostic message indicating if the vehicle is inside or outside a 2D virtual cage defined by a NED origin and a longitude for north and east axis).",Safety,G23,G26,G28,
141,udg_cirs/cola2_core,"Several recovery actions are implemented as ROS services in the recovery_actions node. They can be called using this syntax:

rosservice call cola2_safety/recovery_action *error_level*
Where error_level can be:

INFORMATIVE: Inform that an error is produced
ABORT_MISSION: INFORMATIVE + aborts a goto, submerge, enable_trajectory or keep position service
ABORT_AND_SURFACE: ABORT_MISSION + brings the vehicle to a safety depth
EMERGENCY_SURFACE: ABORT_MISSION + without using the navigation or the control stack sends a setpoint directly to the thrusters to make the vehicle surface.",Safety,G23,,,
142,xuefengchang/micros_swarm_framework,"In order to make it modular and extensible, we chose to decompose the framework into a layered structure, as shown in Fig. 1. The Communication Interface layer is to implement an abstraction of the underlying communication mechanisms, and provides a set of unified interface to layer above. At the core of the framework is a runtime platform, based on which APIs including abstract data structures, such as Swarm, Neighbor, and Virtual Stigmergy, are provided to the user. Upon this core part, we are also trying to build a library of typical swarm algorithms to further facilitate the application development.",,G4,G38,,
143,,,,,,,
144,,,,,,,
145,,,,,,,
146,,,,,,,
147,,,,,,,
148,,,,,,,
149,,,,,,,
150,,,,,,,
151,,,,,,,
152,,,,,,,
153,,,,,,,
154,,,,,,,
155,,,,,,,
156,,,,,,,
157,,,,,,,
158,,,,,,,
159,,,,,,,
160,,,,,,,
161,,,,,,,
162,,,,,,,
163,,,,,,,
164,,,,,,,
165,,,,,,,
166,,,,,,,
167,,,,,,,
168,,,,,,,
169,,,,,,,
170,,,,,,,
171,,,,,,,
172,,,,,,,
173,,,,,,,
174,,,,,,,
175,,,,,,,
176,,,,,,,
177,,,,,,,
178,,,,,,,
179,,,,,,,
180,,,,,,,
181,,,,,,,
182,,,,,,,
183,,,,,,,
184,,,,,,,
185,,,,,,,
186,,,,,,,
187,,,,,,,
188,,,,,,,
189,,,,,,,
190,,,,,,,
191,,,,,,,
192,,,,,,,
193,,,,,,,
194,,,,,,,
195,,,,,,,
196,,,,,,,
197,,,,,,,
198,,,,,,,
199,,,,,,,
200,,,,,,,
201,,,,,,,
202,,,,,,,
203,,,,,,,
204,,,,,,,
205,,,,,,,
206,,,,,,,
207,,,,,,,
208,,,,,,,
209,,,,,,,
210,,,,,,,
211,,,,,,,
212,,,,,,,
213,,,,,,,
214,,,,,,,
215,,,,,,,
216,,,,,,,
217,,,,,,,
218,,,,,,,
219,,,,,,,
220,,,,,,,
221,,,,,,,
222,,,,,,,
223,,,,,,,
224,,,,,,,
225,,,,,,,
226,,,,,,,
227,,,,,,,
228,,,,,,,
229,,,,,,,
230,,,,,,,
231,,,,,,,
232,,,,,,,
233,,,,,,,
234,,,,,,,
235,,,,,,,
236,,,,,,,
237,,,,,,,
238,,,,,,,
239,,,,,,,
240,,,,,,,
241,,,,,,,
242,,,,,,,
243,,,,,,,
244,,,,,,,
245,,,,,,,
246,,,,,,,
247,,,,,,,
248,,,,,,,
249,,,,,,,
250,,,,,,,
251,,,,,,,
252,,,,,,,
253,,,,,,,
254,,,,,,,
255,,,,,,,
256,,,,,,,
257,,,,,,,
258,,,,,,,
259,,,,,,,
260,,,,,,,
261,,,,,,,
262,,,,,,,
263,,,,,,,
264,,,,,,,
265,,,,,,,
266,,,,,,,
267,,,,,,,
268,,,,,,,
269,,,,,,,
270,,,,,,,
271,,,,,,,
272,,,,,,,
273,,,,,,,
274,,,,,,,
275,,,,,,,
276,,,,,,,
277,,,,,,,
278,,,,,,,
279,,,,,,,
280,,,,,,,
281,,,,,,,
282,,,,,,,
283,,,,,,,
284,,,,,,,
285,,,,,,,
286,,,,,,,
287,,,,,,,
288,,,,,,,
289,,,,,,,
290,,,,,,,
291,,,,,,,
292,,,,,,,
293,,,,,,,
294,,,,,,,
295,,,,,,,
296,,,,,,,
297,,,,,,,
298,,,,,,,
299,,,,,,,
300,,,,,,,
301,,,,,,,
302,,,,,,,
303,,,,,,,
304,,,,,,,
305,,,,,,,
306,,,,,,,